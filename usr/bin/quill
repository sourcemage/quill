#!/bin/bash
#---
## @Synopsis Spell creator script for SourceMage GNU/Linux
## @Copyright Copyright 2006 SourceMage GNU/Linux
## @License GPL v2 or higher
##
## @ToDo Add option to use upstream gpg signature as included or
## @ToDo downloadable .sig file
## @ToDo Put a multiversion option
## @ToDo single line or multiline depending on the length of line if
## @ToDo <80 single else multi
## @ToDo Interface to add CONFIGURE options
## @ToDo Automated bugcli submissions of spells
## @ToDo Add a better configuration interface(dialog based I hope)
## @ToDo Make quill the be-all for spells
##
## Asks the user in simple questions about generating a spell.
## @Globals BUILDISON, INSTALLISON, PREBUILDISON, TRIGGERSISON
## @Globals SPELL_HISTORY_NAME, SPELL_HISTORY_EMAIL, SPELL_NAME,
## @Globals SPELL_SRC_URL, SPELL_LICENSE, SPELL_URL, SPELL_SHORT_DESCRIPTION,
## @Globals SPELL_DESCRIPTION, SPELL_DEPENDENCIES, SPELL_OPTIONAL_DEPENDENCIES,
## @Globals SPELL_CONFLICTS, HISOTRY_DATE, SPELL_SRC_FILE,
## @Globals SPELL_SANITIZED_FILE_NAME, SPELL_MD5_UNPACKED, SPELL_VERSION,
## @Globals i, j, n, BUILD_DTFILE, DTFILE_MENUENTRY, DTFILE_EXEC
## @Globals DTFILE_MENUPATH, DTFILE_ICON, DTFILE_TERM, SPELL_SRC_DIR
##
## @Thanks BearPerson, dufflebunk, afrayedknot
## @Thanks To all testers
## @Contribution abouter, lynxlynxlynx, iuso
##
#---
QUILL_VERSION="$(< /var/lib/quill/version)"
#---
## really basic stuff that should be loaded and set
. /var/lib/sorcery/modules/libmedia
LOCAL_MEDIA_CONFIG=/etc/sorcery/local/media source /etc/sorcery/media
function message() { echo -e "$@"; }
. /var/lib/quill/modules/libcore
## end of skeletal prerequisites - we get the rest later

QUILL_MODE="apprentice"
HISTORY_DATE="$(date +%Y-%m-%d)"

QUILL_HOME_DIR=~/.sourcemage/quill
QUILL_QUILLRC=${QUILL_HOME_DIR}/quillrc
QUILL_OLD_QUILLRC=~/.quillrc
QUILL_SPELL_DIR=~/.sourcemage/spells
QUILL_TMP_DIR=~/.sourcemage/tmp

#---
## Not really a function it's supposed to parse the command line parameters
#---
while [[ -n $1 ]]; do
  if grep -q "^ -" <<< " $1"; then
    case  $1  in
      --fmxml|-f)
                  check_parameter $2
                  QUILL_FMXML_MODE="on"
                  shift ;;
   --perlcpan|-c)
                  check_parameter $2
                  QUILL_CPAN_MODE="on"
                  shift ;;
     --update|-u)
                  check_parameter $2
                  QUILL_UPDATE="on"
                  shift ;;
         -uf|-fu)
                  check_parameter $2
                  QUILL_UPDATE="on"
                  QUILL_FMXML_MODE="on"
                  shift ;;
         -uc|-cu)
                  check_parameter $2
                  QUILL_UPDATE="on"
                  QUILL_CPAN_MODE="on"
                  shift ;;
      --purge|-p) QUILL_MODE="purge"; quill_purge $2 ;;
 --apprentice|-a) QUILL_MODE="apprentice" ;;
       --mage|-m) QUILL_MODE="mage" ;;
     --wizard|-w) QUILL_MODE="wizard" ;;
--reconfigure|-r) QUILL_MODE="reconfigure" ;;
       --help|-h) quill_help ;;
    --version|-v) quill_version ;;
               *) message "${PROBLEM_COLOR}Invalid parameter $1$DEFAULT_COLOR"
                  quill_help 102 ;;
    esac
  fi
  shift
done
export QUILL_MODE QUILL_FMXML_MODE QUILL_CPAN_MODE QUILL_TARGET

unset -f message
. /etc/sorcery/config
EDITOR=${EDITOR:-nano}
for i in /var/lib/quill/modules/lib*
do
  . $i
done

quill_rc

# we should do some quillrc sanity checking someday
[[ ! -d $QUILL_SPELL_DIR ]] &&
  echo "Bad QUILL_SPELL_DIR ($QUILL_SPELL_DIR)!" &&
  echo "Try running quill -r" &&
  exit 7

PROMPT_DELAY="31557807"
BUILD_API=2
load_build_api
mkdir -p $QUILL_TMP_DIR

## Down to here... from here it's question and answer time
#---

#---
## Questions and stuff

quill_welcome
if [[ "$QUILL_FMXML_MODE" == "on" ]]
then
  # fetches SPELL_NAME, SPELL_DESC_NAME, SPELL_SRC_URL, SPELL_URL,
  # SPELL_LICENSE and both descriptions
  quill_fmxml_core $QUILL_TARGET

  # creates SPELL_VERSION and SPELL_SRC_FILE (to be SOURCE)
  parse_spell_source_file_info
fi

if [[ "$QUILL_CPAN_MODE" == "on" ]]
then
  quill_cpan_core $QUILL_TARGET

  # creates SPELL_VERSION and SPELL_SRC_FILE (to be SOURCE)
  parse_spell_source_file_info
fi

if [[ "$QUILL_UPDATE" == "on" ]]
then
  SPELL_NAME=$QUILL_TARGET
  codex_does_spell_exist $SPELL_NAME || exit 6

  while true; do
    actions=('Update the spell to a newer version' \
             'Manage patches' \
             'Convert to gpg signing' \
             'Add a SCM version' \
             'Copy it under QUILL_GIT_DIR' \
             'Copy it back to the grimoire' \
             'Try it out' \
             'Quit' )
    echo
    query_list "What do you want to do?" ANSWER "Quit" "${actions[@]}"

    [[ $ANSWER == "Quit" ]] && exit 0

    if [[ $ANSWER != ${actions[4]} || $ANSWER == ${actions[5]} || $ANSWER == ${actions[6]} ]]
    then
      #copy spell over and move there
      codex_get_spell_paths $(codex_find_spell_by_name $SPELL_NAME)
      rm -fr $QUILL_SPELL_DIR/$SPELL_NAME
      cp -r $SECTION_DIRECTORY/$SPELL_NAME $QUILL_SPELL_DIR
      cd $QUILL_SPELL_DIR/$SPELL_NAME
      cp DETAILS DETAILS.orig
    fi
    case "$ANSWER" in
      "${actions[0]}") #"Update the spell to a newer version"

        #fetch current versions, ignoring SCM ones
        versions=( $(sed -n 's/\s*\<VERSION=//p' DETAILS |
                   grep -Eiv '\$[(]date *+|cvs|svn|tla|git|scm' | sort | uniq) )
        message "Current relevant version(s): ${versions[@]}"

        update_counter="${#versions[@]}"
        #suggest the new one from fm and/or ask for input
        for version in "${versions[@]}"
        do
          if query "Do you want to update $version?" y
          then
            query_spell_version

            #save the chosen version
            sed -i "s/\<VERSION=$version\>/VERSION=$SPELL_VERSION/" DETAILS

            #check for multiversion spells
            if [[ $(grep -cE "\<SOURCE.?=" DETAILS) != 1 ]]
            then #we have a problem
              message "Oh dear, detected a multiversion spell. Going to cat DETAILS for you "
              message "and then you will tell me which variable I need to set, so I can get "
              message "to the correct version ($version)."
              sleep 3
              cat DETAILS
              query_string if_var "${QUERY_COLOR}Please enter the appropriate variable. Example: UGU_DEVEL=y${DEFAULT_COLOR} "
            fi

            #check that (usually new) source urls are ok
            get_sources_and_urls

            i=
            for su in $source_urls
            do
              if ! grep -q ftp:// <<< "$su"
              then
                # the return value acrobatics make both blocks return the same
                wget -S --spider "$su" 2>&1 | grep -q "ERROR 404"
                if [[ $? == 0 ]]
                then
                  rc=1
                else
                  rc=0
                fi
              else
                wget -O - -S "${su%/*}/" 2>&1 | grep -q "${su##*/}"
                rc=$?
              fi
              #echo
              #... if they are not ok ask for fixed ones
              if [[ $rc == 0 ]]
              then
                message "SOURCE${i}_URL[0] is ok!"
              else
                message  "SOURCE${i}_URL[0] is broken! Fix it manually."
                sleep 2
                quill_edit DETAILS
              fi
              [[ ! $i ]] && i=1
              let i+=1
            done

            #reparse the possibly new source urls and company
            get_sources_and_urls
            echo

            message "Summoning ..."
            #download; we are not a grimoire so some hacking is needed
            # also workaround sorcery bug #13412
            to_summon="$sources_and_urls"
            for source in $sources
            do
              [[ -e $SOURCE_CACHE/$source ]] &&
              to_summon="$(sed "/^$source /d" <<< "$to_summon")"
            done
            if [[ -z $to_summon ]]
            then
              message "Nothing new to summon, all sources found."
            else
              summon -r <<< "$to_summon"
            fi

            # ask for SECURITY_PATCHing
            update_patchlevel SECURITY_PATCH

            #restore patchlevel?
            update_patchlevel PATCHLEVEL skip remove

            #get hashes and save them, removing any previous hash/gpg
            i=
            for source in $sources
            do
              hash=$(quill_hash_get $SOURCE_CACHE/$source)
              # use the original DETAILS, as we already changed the VERSION
              current_check=$(eval ${if_var:-:}; . DETAILS.orig &> /dev/null; eval echo \$SOURCE${i}_HASH\$SOURCE${i}_GPG\$SOURCE${i}_IGNORE)

              #skip SOURCE_IGNORE
              if grep -Eq "volatile|signature|unversioned" <<< "$current_check"
              then
                [[ ! $i ]] && i=1
                let i+=1
                continue
              fi

              #SOURCE_GPG?
              if ! grep -Eq "(sha(512|256|1)|md5):.*:" <<< "$current_check"
              then #it is a gpg
                if ! query "Do you want to replace SOURCE${i}_GPG with a hash?" n
                then
                  message "Here is the hash for SOURCE$i anyway, if you need it later: $hash"
                  [[ ! $i ]] && i=1
                  let i+=1
                  continue
                #TODO: else sign it and continue
                fi
              fi

              # SOURCE_GPG usually has unexpanded variables, while we have the expanded
              if ! grep -q $current_check DETAILS.orig
              then # looks like it is expanded
                current_check=$(
                eval ${if_var:-:}; . DETAILS.orig &> /dev/null;
                for j in `get_source_nums s`
                do
                  j="${j%s}"
                  SOURCE=$(eval echo \$SOURCE$j)
                  substitute_with_variables current_check "$SOURCE" {SOURCE$j}
                done
                substitute_with_variables current_check "$SPELL_NAME" {SPELL} "$VERSION" {VERSION}
                echo $current_check
                )
              fi
              if ! grep -q $current_check DETAILS.orig
              then # maybe the author doesn't like the ugly braces too
                current_check="$(tr -d "{}" <<< $current_check)"
              fi
              if ! grep -q $current_check DETAILS.orig
              then # give up
                message "Giving up, you'll have to update SOURCE${i}_(GPG|HASH) yourself."
                [[ ! $i ]] && i=1
                let i+=1
                continue
              fi

              #it is either a SOURCE_HASH or the user wants to replace SOURCE_GPG
echo "+$current_check++"
              sed -i "s/^\(\s*\)SOURCE${i}_[^=]*=['\"]*${current_check}['\"]*\s*$/\1SOURCE${i}_HASH=sha512:$hash/" DETAILS

              # remove sigs, trying not to touch any that are still needed
              if ! grep -q "VERSION=$version *$" DETAILS;
              then
                # compgen has a plain wierd output
                files=$(compgen -G "*$version*.sig" | tr '\n' ' ')
                files="$files $(compgen -G "*$version*.asc" | tr '\n' ' ')"
                [[ $files != " " ]] && rm -i $files
              fi

              [[ ! $i ]] && i=1
              let i+=1
            done

            echo
            #update HISTORY
            add_history_entries "DETAILS: updated ${if_var:-spell} to $SPELL_VERSION"
            echo
          else
            let update_counter-=1
          fi
        done

        if [[ $update_counter == 0 ]];
        then # there were no updates
          continue
        fi

        echo
        rm DETAILS.orig
        if query "Do you want to review the update or add custom modifications?" y
        then
          quill_edit
        fi
        echo

        echo
        message "Done with updating the spell!"
        echo

      ;;
      "${actions[1]}") #"Manage patches"
#update patchlevel?
#update HISTORY
#copy the spell back to the grimoire?
        echo ++"$ANSWER"++ ;;
      "${actions[2]}") #"Convert to gpg signing"
#update HISTORY?
#copy the spell back to the grimoire?
        echo ++"$ANSWER"++ ;;
      "${actions[3]}") #"Add a \$SCM version"
#update patchlevel?
#update HISTORY
#copy the spell back to the grimoire?
        echo ++"$ANSWER"++ ;;
      "${actions[4]}") #"Copy it to $QUILL_GIT_DIR"
        copy_to_git
      ;;
      "${actions[5]}") #"Copy it back to the grimoire"
        codex_get_spell_paths $(codex_find_spell_by_name $SPELL_NAME)
        if [[ ! -e $QUILL_SPELL_DIR/$SPELL_NAME ]]
        then
          message "There is nothing to copy back!"
        else
          quill_final_put_in_grimoire $GRIMOIRE $SECTION no
        fi
      ;;
      "${actions[6]}") #"Try it out"
        cast -c $SPELL_NAME
      ;;
    esac

  done
else
  query_spell_name
  query_spell_source_url
  query_spell_license
  query_spell_url
  query_spell_short_description
  query_spell_description
  query_spell_dependencies
  query_spell_optional_dependencies
  query_spell_build
  query_spell_install
  query_spell_desktop_file

  if [[ "${QUILL_MODE}" == "mage" ]] || [[ "${QUILL_MODE}" == "wizard" ]]
  then
    query_spell_pre_build
    query_spell_prepare
    query_spell_conflicts
    #-query_spell_configure
    query_spell_provides
    #-query_spell_final
    #-query_spell_triggers
    #-query_spell_solo
    #-query_spell_configs
    #-query_spell_volatiles
    if [[ "${QUILL_MODE}" == "wizard" ]]
    then
      #-  query_spell_pre_install
      #-  query_spell_post_install
      #-  query_spell_pre_remove
      #-  query_spell_post_remove
      #-  query_spell_pre_resurrect
      #-  query_spell_post_resurrect
      true
    fi
  fi


  create_spell_base

  if [[ "${SPELL_DEPENDENCIES}" != "" ]]
  then
    add_dependencies
  fi

  if [[ "${SPELL_OPTIONAL_DEPENDENCIES}" != "" ]]
  then
    add_optional_dependencies
  fi

  # add && where appropriate in DEPENDS
  if [[ ${SPELL_OPTIONAL_DEPENDENCIES} != "" ]] || [[ ${SPELL_DEPENDENCIES} != "" ]]
  then
    sed -e 's/^ *$//' -e 's/[^\\]$/& \&\&/' DEPENDS | tac |
      awk '{ if (removed!=1){ if (sub("&&$","") > 0){ removed=1 }}; print }' |
      tac > temporary-DEPENDS
    mv temporary-DEPENDS DEPENDS
  fi

  if [[ "${SPELL_CONFLICTS}" != "" ]]
  then
    add_conflicts
  fi

  if [[ "${SPELL_PROVIDES}" != "" ]]
  then
    add_provides
  fi

  # redo it for fmxml - so it works if the xml didn't contain a valid source url
  # first time for other modes
  parse_spell_source_file_info
  show_spell_source_file_info
  echo

  get_spell_source

  hunt_src_dir

  add_details

  if [[ "${PREPAREISON}" == "PREPARE, " ]]
  then
    add_prepare
  fi

  #-if [[ "${CONFIGUREISON}" == "CONFIGURE, " ]]
  #-then
  #-  add_configure
  #-fi

  if [[ "${PREBUILDISON}" == "PRE_BUILD, " ]]
  then
    add_pre_build
  fi

  if [[ "${BUILDISON}" == "BUILD, " ]]
  then
    add_build
  fi

  if [[ "${INSTALLISON}" == "INSTALL, " ]]
  then
    add_install
  fi

  #-if [[ "${POSTINSTALLISON}" == "POST_INSTALL, " ]]
  #-then
  #-  add_post_install
  #-fi

  #-if [[ "${TRIGGERSISON}" == "TRIGGERS, " ]]
  #-then
  #-  add_triggers
  #-fi

  if [[ "${BUILD_DTFILE}" != "" ]]
  then
    add_desktop_file
  fi

  add_history
  quill_set_executable_bit
  if query "Do you want to edit all the spell files?" n
  then
    quill_edit
  fi
  if query "Do you want to tarball the spell?" n
  then
    quill_final_tarball
  fi
  message ""
  message "The spell has been generated and put into: $QUILL_SPELL_DIR/$SPELL_NAME"
  if query "Do you want to put the spell into one of the avialable grimoires?" n
  then
    quill_final_put_in_grimoire &&
    if query "Do you want to *try* to cast the spell?" n
    then
      cast $SPELL_NAME
    fi
  fi
fi
message "That's all folks!"

#---
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---
