#---
## @Synopsis query_list function from init-manager
## $1 - the question
## $2 - the VARIABLE to which to store the answer
## $3 - the default answer
## $4...$n - the options for the list
#---
function query_list()
{
  local question="$1"
  shift
  query_msg "$question"
  select_list "$@"
}

#---
## @Synopsis generate basic spell dir
#---
function create_spell_base(){
  mkdir -p ${QUILL_SPELL_DIR}/${SPELL_NAME}
  cd ${QUILL_SPELL_DIR}/${SPELL_NAME}
  touch DETAILS
  chmod +x DETAILS
  DEPENDSISON=""
  CONFLICTSON=""
}

#---
## @Synopsis download spell's source file
#---

function get_spell_source(){
  mkdir -p ${QUILL_TMP_DIR}
  cd ${QUILL_TMP_DIR}
  if [[ -e $SPELL_SRC_FILE ]]; then
    message "Found the spell tarball in the quill dir, continuing ..."
  elif [[ -e $SOURCE_CACHE/$SPELL_SRC_FILE ]]; then
    message "Found the spell tarball in the sorcery cache, copying it over ..."
    cp $SOURCE_CACHE/$SPELL_SRC_FILE .
    message "Done."
  else
    wget -c "${SPELL_SRC_URL}"
  fi
  cd ${QUILL_SPELL_DIR}/${SPELL_NAME}
}

#---
## @Synopsis Print the sha512 hash, a simplified gpg_hashsum
##
#---

function quill_hash_get() {
  gpg --print-md sha512 "$@" | tr -d '\n ' | tr 'A-F' 'a-f' | cut -d: -f2
}

#---
## @Synopsis Get's gurus info and stuff and puts it into
## @Synopsis $QUILL_QUILLRC or reads it from there
#---

function quill_rc() {
  local saved
  if [[ -f ${QUILL_OLD_QUILLRC} ]]
  then
    query_msg "With accordance to Source Mage standards moving"
    query_msg "$QUILL_OLD_QUILLRC to $QUILL_QUILLRC"
    mkdir -p ~/.sourcemage/quill
    cp ${QUILL_OLD_QUILLRC} ${QUILL_QUILLRC}
    if [[ -f ${QUILL_QUILLRC} ]]
    then
      query_msg "Removing $QUILL_OLD_QUILLRC"
      rm ${QUILL_OLD_QUILLRC}
    else
      error_msg "Ugghhh... something went wrong..."
    fi
  fi
  if [[ ! -f ${QUILL_QUILLRC} ]] ||
     [[ $QUILL_MODE == reconfigure ]]
  then
    mkdir -p $QUILL_HOME_DIR
    touch $QUILL_QUILLRC
    . $QUILL_QUILLRC # get the contents if there are any (for defaults)
    message "${MESSAGE_COLOR}This will (re)create ${QUILL_QUILLRC} for you${DEFAULT_COLOR}"
    query_string GURU_NAME "${QUERY_COLOR}Please enter your name for the HISTORY entries.${DEFAULT_COLOR}" "$GURU_NAME"
    query_string GURU_EMAIL "${QUERY_COLOR}Please enter your email for the HISTORY entries.${DEFAULT_COLOR}" "$GURU_EMAIL"
    query_string QUILL_SPELL_DIR "${QUERY_COLOR}Where do you want to store generated spells (absolute path)?${DEFAULT_COLOR}" "$QUILL_SPELL_DIR"
    query_string QUILL_GIT_DIR "${QUERY_COLOR}Where is the dir that contains your git grimoires if you have any (absolute path)?${DEFAULT_COLOR}" "$QUILL_GIT_DIR"

    if [[ -z $QUILL_SUDO ]]; then
      saved=n
    else
      [[ -z ${QUILL_SUDO/sudo bash/} ]] && saved=y || saved=n
    fi
    if query "Do you want to use sudo where possible?" $saved; then
      # we need the bash since we call multiple commands at a time
      # and sudo doesn't like just sudo -c "ls; ls; ls"
      QUILL_SUDO="sudo bash"
    else
      QUILL_SUDO="su"
    fi

    [[ -z $GURU_GPGKEY ]] && saved=n || saved=y
    if query "Do you use guru GPG signatures?" $saved ; then
      query_list "${QUERY_COLOR}Please select one of the following keys as the guru signing key${DEFAULT_COLOR}" GURU_GPGKEY "$GURU_GPGKEY" $(gpg -K | sed -n "/^sec[^#]/ s,^sec\s*[^/]*/\(\S*\)\s.*$,\1,p")
    fi

    message "Thank you. Now generating ${QUILL_QUILLRC}"
    cat << QUA > $QUILL_QUILLRC
  QUILL_CONFIG_VERSION="$QUILL_OUR_CONFIG_VERSION"
  GURU_NAME="$GURU_NAME"
  GURU_EMAIL="$GURU_EMAIL"
  QUILL_SPELL_DIR="$QUILL_SPELL_DIR"
  QUILL_GIT_DIR="$QUILL_GIT_DIR"
  QUILL_SUDO="$QUILL_SUDO"
  GURU_GPGKEY="$GURU_GPGKEY"
QUA
    mkdir -p "$QUILL_SPELL_DIR" "$QUILL_GIT_DIR"
    exit 0
  else
     . $QUILL_QUILLRC
  fi
}

#---
## @Synopsis The welcome message for quill
function quill_welcome() {
  message "Welcome to SourceMage GNU/Linux quill - a spell creator and updater script."
  message "-----------------------------------------------------------------------------"
  message "This makes an immediately useable spell from some minor data or "
  message "updates an exsisting one.."
  message "-----------------------------------------------------------------------------"
  message "The spell will be put into a grimoire/section you define(if you choose to)"
  message "and a tar.bz2 file will be created in $QUILL_SPELL_DIR."
  message "-----------------------------------------------------------------------------"
  message "All lists should be space delimited(dependencies and optional dependencies)"
  message "-----------------------------------------------------------------------------"
}

#---
## @Synopsis used to edit spell files
#---
function quill_edit() {
  local spell_file type

  message "Now invoking $EDITOR to edit ${1:-spell files}."
  cd ${QUILL_SPELL_DIR}/${SPELL_NAME}
  for spell_file in ${1:-*}
  do
    type=$(file -bi $spell_file)
    if list_find "$type" "text/plain;"
    then
      $EDITOR $spell_file
    fi
  done
  message "All modifications complete."
}

#---
## @Synopsis generate a tarball of the spell
#---
function quill_final_tarball() {
  message "Now creating a bziped2 tarball of the spell files"
  cd ${QUILL_SPELL_DIR}
  tar -jcvf ${SPELL_NAME}.tar.bz2 ${SPELL_NAME}
  if [[ $? != 0 ]]; then
     error_msg "Failed to create spell tarball"
  else
     message "Spell tarball created successfully"
  fi
}

#---
## @Synopsis function to chmod +x all the relevant spell files
#---
function quill_set_executable_bit() {
  for SPELL_FILE in ${QUILL_SPELL_DIR}/${SPELL_NAME}/*
  do
    if [[ "$SPELL_FILE" != "${QUILL_SPELL_DIR}/${SPELL_NAME}/HISTORY" ]]
    then
      chmod +x $SPELL_FILE
    fi
  done
}

#---
## @Synopsis function to put the spell into the grimoire. The first two args
##           toggle interactivity and the third the reindexing of the grimoire
##
## @param internal flag toggling interactivity - grimoire (canonical)
## @param internal flag toggling interactivity - section name
## @param flag toggling scribe reindex, set it to "no" to toggle
#---
function quill_final_put_in_grimoire() {
  local reindex=$3

  if [[ -z $2 ]]; then
    query_list "Into which grimoire do you wish to put the spell:" QUILL_GRIM_NAME \
      "" $(codex_get_all_grimoires | get_basenames)
    echo
    QUILL_GRIM_NAME=$(codex_canonicalize_grimoire_name $QUILL_GRIM_NAME)

    # can't use query_list, as the section count can be bigger than the available index
    message "Available sections in grimoire $QUILL_GRIM_NAME:"
    codex_get_section_names $QUILL_GRIM_NAME | column
    query_string QUILL_SECT_NAME "Into which section do you wish to put the spell: "

    if [[ -e $QUILL_GRIM_NAME/$QUILL_SECT_NAME/$SPELL_NAME ]]; then
      message "${MESSAGE_COLOR}There is an exsisting spell for $SPELL_NAME in $QUILL_GRIM_NAME/$QUILL_SECT_NAME"
      if query "Do you want to overwrite it?" y; then
        reindex=no
      else
        quill_final_put_in_grimoire
        return
      fi
    fi
  else
    QUILL_GRIM_NAME="$1"
    QUILL_SECT_NAME="$2"
  fi
  message "Copying spell into $QUILL_GRIM_NAME/$QUILL_SECT_NAME/$SPELL_NAME ..."

  quill_final_put_in_grimoire_sub(){
    mkdir -p $QUILL_GRIM_NAME/$QUILL_SECT_NAME/$SPELL_NAME || return 1

    # we wipe it first, so we can handle any files that we deleted before
    rm -r "$QUILL_GRIM_NAME/$QUILL_SECT_NAME/$SPELL_NAME" || return 1
    rm -f "$QUILL_SPELL_DIR/$SPELL_NAME/DETAILS.orig"

    cp -pr $QUILL_SPELL_DIR/$SPELL_NAME $QUILL_GRIM_NAME/$QUILL_SECT_NAME/
    if [[ $? != 0 ]]; then
      error_msg "Copying failed!"
      return 1
    else
      echo "Copying succeded."
      if [[ $1 != no ]]; then
        echo
        echo "Running scribe reindex on $QUILL_GRIM_NAME ..."
        scribe reindex $(basename $QUILL_GRIM_NAME)
      fi
    fi
  }

  if [[ -w $QUILL_GRIM_NAME && -w $QUILL_GRIM_NAME/$QUILL_SECT_NAME ]]; then
    quill_final_put_in_grimoire_sub $reindex
    if [[ $? == 1 ]]
    then
      error_msg "Permission problems, trying as root ..."
      export QUILL_GRIM_NAME QUILL_SECT_NAME QUILL_SPELL_DIR SPELL_NAME
      ${QUILL_SUDO:-su} -c "$(declare -f quill_final_put_in_grimoire_sub); \
        quill_final_put_in_grimoire_sub $reindex"
    fi
  else
    export QUILL_GRIM_NAME QUILL_SECT_NAME QUILL_SPELL_DIR SPELL_NAME
    ${QUILL_SUDO:-su} -c "$(declare -f quill_final_put_in_grimoire_sub); \
      quill_final_put_in_grimoire_sub $reindex"
  fi

}

#---
## @Synopsis cleans out $QUILL_TMP_DIR and/or $QUILL_SPELL_DIR
#---
function quill_purge() {
  quill_rc
  message -n "Purging ... "
  if [[ $1 == "tmp" ]]
  then
    [[ -d $QUILL_TMP_DIR ]] && rm -rf $QUILL_TMP_DIR && mkdir $QUILL_TMP_DIR
  elif [[ $1 == "spells" ]]
  then
    [[ -d $QUILL_SPELL_DIR ]] && rm -rf $QUILL_SPELL_DIR && mkdir $QUILL_SPELL_DIR
  else
    [[ -d $QUILL_TMP_DIR ]] && [[ -d $QUILL_SPELL_DIR ]] && rm -rf $QUILL_SPELL_DIR $QUILL_TMP_DIR && mkdir $QUILL_TMP_DIR $QUILL_SPELL_DIR
  fi

  rc=$?
  if [[ $rc == 0 ]]
  then
    message "done."
  else
    error_msg "failed!"
  fi
  exit $rc
}

#---
## @Synopsis checks if spell source urls are valid
## @Synopsis and perhaps changes them if they are trivially fixable
#---
function check_source_urls() {
  local i= su old_su oldest_su source old_source

  message "Checking source urls (this may take a while) ..."
  for su in $source_urls
  do
    check_source_url "$su" "$i"
    if [[ $? == 0 ]]
    then
      message "SOURCE${i}_URL[0] is ok!"
    else
      # first retry with a changed suffix
      old_su="$su"
      [[ ${su/.gz/.bz2} == $su ]] && su="${su/.bz2/.gz}" || su="${su/.gz/.bz2}"
      if check_source_url "$su" "$i"
      then
        message "SOURCE${i}_URL[0] is ok after changing the file extension!"
        # tricky tricky - if we only change the url, it is likely
        # that the accompanying SOURCE will be bad. So we need to change
        # SOURCEn too. Or just that, if the url contains it as a variable

        # try to unexpanded the url - maybe changing the source is enough
        old_source=$(sed -n "s, $old_su,,p" <<< "$sources_and_urls")
        source="$old_source"
        if [[ ${source/.gz/.bz2} == $source ]]
        then
          source="${source/.bz2/.gz}"
        else
          source="${source/.gz/.bz2}"
        fi

        # we need another one since $old_source would match only $old_su
        # and we also need the substituted $old_su
        oldest_su="$old_su"
        substitute_with_variables old_su "$old_source" {SOURCE$i}
        if grep -Eq "\.(bz2|gz)$"  <<< "$old_su"
        then
          # the url most likely does not use SOURCE then
          # however if it does, lets put the substitutions in anyway
          # so we change the url in the file; reparsing is the next call
          # also check if it contains the old expanded VERSION ($version)

          # substitute the longer string first, more likely to give correct results
          # think 1.2 and 1.2.1
          if (( ${#SPELL_VERSION} > ${#version} ))
          then
            substitute_with_variables su "$old_source" {SOURCE$i} "$SPELL_NAME" {SPELL} "$SPELL_VERSION" {VERSION} "$version" {VERSION}
          else
            substitute_with_variables su "$old_source" {SOURCE$i} "$SPELL_NAME" {SPELL} "$version" {VERSION} "$SPELL_VERSION" {VERSION}
          fi

          # some urls may contain other expanded vars that we are not aware of
          if grep -q "$oldest_su" DETAILS
          then # all is fine
            sed -i "s,$oldest_su,$su," DETAILS
          else
            error_msg "Couldn't find $oldest_su in DETAILS,"
            error_msg "probably due to it containing nonstandard variables"
            message "Replace it manually with $su"
          fi
          add_history_entry "DETAILS: Changed SOURCE${i}_URL[0] extension"
        else
          substitute_with_variables source "$SPELL_NAME" {SPELL} "$SPELL_VERSION" {VERSION}
          sed -i "s,$old_source,$source," DETAILS
          # we don't know if the SOURCE is expanded or not, trying just both extremes
          substitute_with_variables old_source "$SPELL_NAME" {SPELL} "$SPELL_VERSION" {VERSION}
          sed -i "s,$old_source,$source," DETAILS
          # and with the beautiful syntax last
          old_source="$(tr -d "{}" <<< "$old_source")"
          sed -i "s,$old_source,$source," DETAILS
          add_history_entry "DETAILS: Changed SOURCE${i} extension"
        fi

      else
        # if they are still not ok ask for fixed ones
        error_msg  "SOURCE${i}_URL[0] is hopelessly broken! Fix it manually."
        sleep 2
        quill_edit DETAILS
      fi
    fi
    [[ ! $i ]] && i=1
    let i+=1
  done

}

#---
## @Synopsis checks if passed source url is valid
##
## @param source url
## @param current source iterator
##
## @return 0 if source url either is valid or just not trivially checkable
## @return 1 otherwise (http or ftp source url failure)
#---
function check_source_url() {
  local rc su="$1" i="$2"

  if grep -q ftp:// <<< "$su"
  then
    wget -O - -S "${su%/*}/" 2>&1 | grep -q "${su##*/}"
    rc=$?
  elif grep -q http:// <<< "$su"
  then
    # the return value acrobatics make both blocks return the same
    wget -S --spider "$su" 2>&1 | grep -Eq "ERROR 404|service not known"
    if [[ $? == 0 ]]
    then
      rc=1
    else
      rc=0
    fi
  else
    message "SOURCE${i}_URL[0] is not a http or ftp link, assuming it works."
    rc=0
  fi

  return $rc
}

#---
## @Synopsis dumps the default spell file function, taking into
## account that devel has a new spell file inheritance scheme
#---
function dump_default_function() {
  if ! declare -f real_default_sorcery_$1; then
    # old sorcery
    declare -f real_default_$1
  fi | sed -e '1,3 d' -e '$ d' -e 's,    ,,'
}

#---
## @Synopsis function that displays the version and exits
#---
function quill_version() {

  message "quill - $QUILL_VERSION
Copyright (C) 2006-2007 Source Mage
This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

Originally written by:
Andraž 'ruskie' Levstik
Rewritten by:
Andraž 'ruskie' Levstik
Jaka 'lynxlynxlynx' Kranjc
Juuso 'iuso' Alasuutari

Contributions by:
Andrew 'afrayedknot' Stitt
Arjan 'abouter' Bouter
"
  exit 0
}

#---
## @Synopsis checks if the parameter is missing
## @Synopsis if not, saves it in QUILL_TARGET
#---
function check_parameter() {
  [[ -z $1 ]] &&
  error_msg "Missing parameter" &&
  quill_help 101 ||
  QUILL_TARGET=$(tr '[[:upper:]]' '[[:lower:]]' <<< "$1")
}

#---
## @Synopsis verbosely checks if the argument is a dir and optionally exits
##
## @param path
## @param (optional) be fatal
##
## @return 0 if it is a dir
## @return 1 otherwise
#---
function dir_check() {
  if [[ ! -d $1 ]]
  then
    error_msg "Not a directory: $1!"
    if [[ -z $2 ]]
    then
      return 1
    else
      exit 17
    fi
  fi
  return 0
}

#---
## @Synopsis adds && to all full lines not ending by and escape \ or last line
#---
function andand_lines() {
  local file="$1"
  sed -e 's/^ *$//' -e 's/[^\\]$/& \&\&/' "$file" |
    tac |
    awk '{ if (removed!=1){ if (sub("&&$","") > 0){ removed=1 }}; print }' |
    tac > "temporary-$file"
  mv "temporary-$file" "$file"
}

#---
## @Synopsis prints a colored error message
#---
function error_msg() {
  message "$PROBLEM_COLOR$@$DEFAULT_COLOR"
}

#---
## @Synopsis prints a colored query message
#---
function query_msg() {
  message "$QUERY_COLOR$@$DEFAULT_COLOR"
}

#---
## @Synopsis function that displays help and exits
#---
function quill_help() {

  message "quill $QUILL_VERSION
Copyright (C) 2006-2007 Source Mage
This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

USAGE: quill [OPTIONS]
A spell creator and updater.

OPTIONS:
  --fmxml, -f <SPELL>		get spell data from Freshmeat if possible
  --perlcpan, -c <SPELL>	get spell data from Perl-CPAN if possible
  --rubyraa, -y <SPELL>		get spell data from Ruby Application Archive if possible
  --update, -u <SPELL>		update exsisting spell
  --apprentice, -a		apprentice mode	(default)
  --mage, -m			mage mode (advanced)
  --wizard, -w			wizard mode (expert)(DOES NOTHING FOR NOW)
  --help, -h			display this help
  --version, -v			display version
  --reconfigure, -r		reconfigure settings
  --purge, -p [spells|tmp]	purge internal quill files, defaults to both dirs

EXAMPLES:
  Create a spell; try to get some information from Freshmeat and ask about some
  additional spell files:
    quill -f wormux -m

  Update a spell; try to get some information from Perl-CPAN:
    quill -c wormux -u wormux

  The same can be done with shorter forms (fu, uc, yu and inverses are supported):
    quill -cu wormux
"
  exit ${1:-0}
}


#---
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---

